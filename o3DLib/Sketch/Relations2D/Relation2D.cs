//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace o3DLib.Sketching.Relations2D
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Extensions;
    using Helpers;
    using System.Windows;

    public abstract class Relation2D : IRelation2D, IDisposable
	{
        #region Properties

        private bool IsReversable { get { return (this is IReversable); } }

        public virtual Relation2D Parent { get; set; }

        public IList<IRelatable> Relatables { get; set; } = new List<IRelatable>();

        public IList<IRelation2D> ChildRelations { get; set; } = new List<IRelation2D>();

        public string Name { get { return this.GetType().Name; } }
        #endregion

        #region Constructors
        public Relation2D(params Point2D[] points)
        {
            var point = points.Last();
            if (point == null)
                throw new Exceptions.InvalidSetRelationException();

            points.ToList<Point2D>().ForEach((p) => { Relatables.Add(p); });

            IIntersectable previousRelations = point.SatisfyRelations();

            IIntersectable i = Satisfy();
            

            if (i == null)
                throw new Exceptions.InvalidSetRelationException();

            IList<Point> intersect = previousRelations != null ? previousRelations.Intersection(i) : null;
            if (previousRelations == null || intersect.Count() > 0)
            {
                Point? p;
                if (previousRelations == null)
                    p = i.GetNearest(point.Point);
                else
                {
                    p = intersect.GetNearest(point.Point);
                }


                point.Point = p != null ? p.Value : point.Point;

                foreach (Point2D pt in points)
                    if (!pt.Relations2D.Contains(this))
                        pt.Relations2D.Add(this);
            }
            else
                throw new Exceptions.ConflictRelationException();
        }


        public Relation2D(params IRelatable[] relatables)
        {

            List<Point2D> points = new List<Point2D>();

            foreach (IRelatable relatable in relatables)
            {
                points.AddMany(relatable.GetRelatingPoints());
            }

            // Stores the positions before executing the relation
            IList<Point> positions = new List<Point>();
            foreach(Point2D p in points)
            {
                positions.Add(p.Point);
            }

            // Executes the relation
            IList<Relation2D> chRels = new List<Relation2D>();
            try {
                chRels = this.ByPass(points.ToArray<Point2D>());
            } catch (Exception e)
            {
                if(e is Exceptions.ConflictRelationException && this.IsReversable)
                {
                    // Reverse last two points
                    Point2D temp = points[points.Count - 1];
                    points[points.Count - 1] = points[points.Count - 2];
                    points[points.Count - 2] = temp;
                    positions[positions.Count - 1] = points[points.Count - 1].Point;
                    positions[positions.Count - 2] = points[points.Count - 2].Point;

                    try {
                        chRels = this.ByPass(points.ToArray<Point2D>());
                    } catch(Exception e2)
                    {
                        // Failed, return points into previous state
                        returnToThePreviousState(positions, points, chRels);
                        throwException(e2);
                        this.Dispose();
                        return;
                    }
                } else
                {
                    returnToThePreviousState(positions, points, chRels);
                    throwException(e);
                    this.Dispose();
                    return;
                }
            }

            bool collapsed = false;

            foreach (IRelatable relatable in relatables)
            {
                if(relatable is Entity2D)
                    if ((relatable as Entity2D).Points2D.First().Point.IsEqual((relatable as Entity2D).Points2D.Last().Point))
                        collapsed = true;
                this.Relatables.Add(relatable);
                if (!relatable.Relations2D.Contains(this) && chRels.Count > 0)
                    relatable.Relations2D.Add(this);
            }

            // If entity collapsed into singularity
            if (collapsed)
            {
                MessageBox.Show("Current relation is in conflict with the previous relations");
                // Returns the points into previous state
                for (int i = 0; i < points.Count(); i++)
                    points[i].Point = positions[i];
                // Disposes the relation
                this.Dispose();
                return;
            }

            foreach (Relation2D chRel in chRels)
            {
                chRel.Parent = this;
                this.ChildRelations.Add(chRel as IRelation2D);
            }

        }
        #endregion
        
        #region Abstracts
        public abstract IList<Relation2D> ByPass(params Point2D[] points);

        public abstract IIntersectable Satisfy();
        #endregion


        #region Methods
        public bool IsDriven(IRelatable relatable)
        {
            return this.Relatables.Last() == relatable;
        }
         
        public Point2D GetDriven()
        {
            IRelatable last = this.Relatables.Last();
            return (last is Point2D) ? last as Point2D : null;
        }

        private void throwException(Exception e)
        {
            if (e is Exceptions.ConflictRelationException)
                MessageBox.Show("Current relation is in conflict with the previous");
            else if (e is Exceptions.InvalidSetRelationException)
                MessageBox.Show("The relation is not applyable on the current set of entities");
            else throw e;
        }

        private void returnToThePreviousState(IList<Point> previousPositions, IList<Point2D> points, IList<Relation2D> chRels)
        {
            for (int i = 0; i < previousPositions.Count(); i++)
            {
                points[i].Point = previousPositions[i];
                foreach (Relation2D chRel in chRels)
                    points[i].Relations2D.TryRemove(chRel);
            }
        }

        #endregion

        
        
        
        #region IDisposable Support
        private bool disposedValue = false;

        protected virtual void Dispose(bool disposing)
        {
            try {
                if (!disposedValue)
                {
                    if (disposing)
                    {
                        if (this.Parent != null)
                            this.Parent.Dispose();
                        foreach (IRelatable r in this.Relatables)
                            if(r != null && r.Relations2D != null)
                                r.Relations2D.Remove(this);
                        foreach (Relation2D chRel in this.ChildRelations)
                        {

                            chRel.Parent = null;
                            chRel.Dispose();
                        }
                    }
                    this.Parent = null;
                    this.Relatables = null;
                    this.ChildRelations = null;

                    disposedValue = true;
                }
            } catch(Exception e) { }
        }

        public void Dispose()
        {
            Dispose(true);
        }
        #endregion

    }
}

