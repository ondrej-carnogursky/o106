//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace o3DLib.Sketching.Relations2D
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Extensions;
    using Helpers;
    using System.Windows;

    public abstract class Relation2D : IRelation2D, IDisposable
	{
        #region Properties
        public virtual Relation2D Parent { get; set; }

        public IList<IRelatable> Relatables { get; set; } = new List<IRelatable>();

        public IList<IRelation2D> ChildRelations { get; set; } = new List<IRelation2D>();
        #endregion

        #region Constructors
        public Relation2D(params Point2D[] points)
        {
            var point = points.Last();

            points.ToList<Point2D>().ForEach((p) => { Relatables.Add(p); });

            IIntersectable previousRelations = point.SatisfyRelations();

            IIntersectable i = Satisfy();
            IList<Point> intersect = previousRelations != null ? previousRelations.Intersection(i) : null;
            if (previousRelations == null || intersect.Count() > 0)
            {
                Point? p;
                if (previousRelations == null)
                    p = i.GetNearest(point.Point);
                else
                {
                    p = intersect.GetNearest(point.Point);
                }


                point.Point = p != null ? p.Value : point.Point;

                foreach (Point2D pt in points)
                    pt.Relations2D.Add(this);
            }
            else
            {
                MessageBox.Show("Current relation is in conflict with the previous relations");
                this.Dispose();
            }
        }


        public Relation2D(params Entity2D[] entities)
        {

            List<Point2D> points = new List<Point2D>();

            foreach (Entity2D entity in entities)
                points.AddMany(entity.GetRelatingPoints());

            // Stores the positions before executing the relation
            IList<Point> positions = new List<Point>();
            foreach(Point2D p in points)
            {
                positions.Add(p.Point);
            }

            // Executes the relation
            IList<Relation2D> chRels = this.ByPass(points.ToArray<Point2D>());

            bool collapsed = false;

            foreach (Entity2D entity in entities)
            {
                if (entity.Points2D.First().Point.IsEqual(entity.Points2D.Last().Point))
                    collapsed = true;
                this.Relatables.Add(entity);
            }

            // If entity collapsed into singularity
            if (collapsed)
            {
                MessageBox.Show("Current relation is in conflict with the previous relations");
                // Returns the points into previous state
                for (int i = 0; i < points.Count(); i++)
                    points[i].Point = positions[i];
                // Disposes the relation
                this.Dispose();
                return;
            }

            foreach (Relation2D chRel in chRels)
            {
                chRel.Parent = this;
                this.ChildRelations.Add(chRel as IRelation2D);
            }

        }
        #endregion
        
        #region Abstracts
        public abstract IList<Relation2D> ByPass(params Point2D[] points);

        public abstract IIntersectable Satisfy();
        #endregion


        #region Methods
        public bool IsDriven(IRelatable relatable)
        {
            return this.Relatables.Last() == relatable && this.Relatables.Count() > 1;
        }

        public Point2D GetDriven()
        {
            IRelatable last = this.Relatables.Last();
            return (last is Point2D) ? last as Point2D : null;
        }
        #endregion

        #region IDisposable Support
        private bool disposedValue = false;

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if(this.Parent != null)
                        this.Parent.Dispose();
                    foreach(IRelatable r in this.Relatables)
                    {
                        r.Relations2D.Remove(this);
                    }
                    foreach(Relation2D chRel in this.ChildRelations)
                    {
                        chRel.Parent = null;
                        this.Dispose();
                    }
                }
                this.Parent = null;
                this.Relatables = null;
                this.ChildRelations = null;

                disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
        }
        #endregion

    }
}

